<!doctype html>
<head>
<title>Collision detection prototype</title>
<script src="../src/vector.js"></script>
<script src="../src/physics.js"></script>
<script>

const segments = [];
const points = [];
const rects = [];
const colours = ['green', 'blue', 'red', 'purple', 'cyan', 'crimson', 'deeppink', 'skyblue', 'indigo', 'orange'];

const collisionPoints = [];

const boundingRadius = 1.5;

class Segment {
    constructor(position, vector) {
        this.position = position;
        this.vector = vector;
        segments.push(this);
    }

    startPoint() {
        return this.position;
    }

    midPoint() {
        return this.vector.midPoint().translate(this.position);
    }

    endPoint() {
        return this.position.copy().translate(this.vector);
    }
}

function drawSegment(s, colour) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', `M${s.position.x},${s.position.y} l${s.vector.x},${s.vector.y}`);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', colour);
    path.setAttribute('stroke-width', '0.1');
    path.setAttribute('marker-end', 'url(#arrow)');
    document.querySelector('#gameobjects').appendChild(path);
}

function drawPoint(point, colour) {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', point.x);
    circle.setAttribute('cy', point.y);
    circle.setAttribute('r', '0.12');
    circle.setAttribute('fill', colour);
    document.querySelector('#gameobjects').appendChild(circle);
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', '0');
    text.setAttribute('y', '0');
    text.setAttribute('font-size', '0.03');
    text.setAttribute('transform', `scale(1,-1) translate(${point.x+0.15},-${point.y-0.1})`);
    text.setAttribute('fill', colour);
    text.innerHTML = `(${point.x.toFixed(2)},${point.y.toFixed(2)})`;
    document.querySelector('#gameobjects').appendChild(text);
}

function drawBoundary(position, colour) {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', position.x);
    circle.setAttribute('cy', position.y);
    circle.setAttribute('r', boundingRadius);
    circle.setAttribute('fill', 'none');
    circle.setAttribute('stroke', colour);
    circle.setAttribute('stroke-width', '0.05');
    document.querySelector('#gameobjects').appendChild(circle);
}

function drawRect(rect, colour) {
    const e = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    e.x.baseVal.value = rect.x1;
    e.y.baseVal.value = rect.y1;
    e.width.baseVal.value = rect.width;
    e.height.baseVal.value = rect.height;
    e.setAttribute('fill', 'none');
    e.setAttribute('stroke', colour);
    e.setAttribute('stroke-width', '0.05');
    document.querySelector('#gameobjects').appendChild(e);
}

function drawAll() {
    let colour = 0;
    segments.forEach(segment => drawSegment(segment, '#999'));
    points.forEach(point => drawPoint(point, 'darkblue'));
    points.forEach(point => drawBoundary(point, '#CCC'));
    rects.forEach(rect => drawRect(rect, 'skyblue'));
    collisionPoints.forEach(point => drawPoint(point, 'red'));
    collisionPoints.forEach(point => drawBoundary(point, 'red'));
}

window.onload = function() {
    const a = new Segment(new Point(1,3), new Vector2d(6,2));
    const b = new Segment(new Point(8,1), new Vector2d(-3,8));

    // Create a bounding box that encompases all possible positions that
    // an object will occupy this update.
    const collisionRectA =
        new Rect(
            a.startPoint().x + (a.startPoint().x < a.endPoint().x ? -boundingRadius : boundingRadius),
            a.startPoint().y + (a.startPoint().y < a.endPoint().y ? -boundingRadius : boundingRadius),
            a.endPoint().x + (a.startPoint().x < a.endPoint().x ? boundingRadius : -boundingRadius),
            a.endPoint().y + (a.startPoint().y < a.endPoint().y ? boundingRadius : -boundingRadius)
        );
    rects.push(collisionRectA);

    const collisionRectB =
        new Rect(
            b.startPoint().x + (b.startPoint().x < b.endPoint().x ? -boundingRadius : boundingRadius),
            b.startPoint().y + (b.startPoint().y < b.endPoint().y ? -boundingRadius : boundingRadius),
            b.endPoint().x + (b.startPoint().x < b.endPoint().x ? boundingRadius : -boundingRadius),
            b.endPoint().y + (b.startPoint().y < b.endPoint().y ? boundingRadius : -boundingRadius)
        );
    rects.push(collisionRectB);

    console.log(`${collisionRectA.intersects(collisionRectB) ? 'P' : 'No p'}otential collision.`);

    const steps = 4;
    const step = 1 / (steps - 1)
    let p = 0;

    for (let i = 0; i < steps; i++, p += step) {
        const aPoint = a.vector.pointAt(p).translate(a.position);
        const bPoint = b.vector.pointAt(p).translate(b.position);

        if (aPoint.distanceTo(bPoint) < boundingRadius * 2) {
            console.log('Collision found.');
            collisionPoints.push(aPoint);
            collisionPoints.push(bPoint);
        } else {
            points.push(aPoint);
            points.push(bPoint);
        }
    }

    drawAll();
}

</script>
<style>
body {font-family: sans-serif;}
svg {height: 95vh;}
marker {overflow: visible;}
</style>
</head>
<body>
<svg id='render' viewBox="0 0 10 10">
<defs>
<marker id="arrow" viewBox="0 0 10 10" markerWidth="6" markerHeight="6" orient="auto">
    <path d="M0,-5 l5,5 l-5,5 z" fill="grey"/>
</marker>
</defs>
<g transform='translate(0,10) scale(1,-1) ' id="gameobjects">
<path d="M0,-100 v200 M-100,0 h200" stroke='#666' stroke-dasharray='0.2' stroke-width="0.1"/>
</g>
</svg>
</body>
</html>
